/*
 * Problem 12: Highly Divisible Triangular Number
 *
 * https://projecteuler.net/problem=12
 *
 * Goal: Find the value of the first triangle number to have more than N divisors.
 *
 * Constraints: 1 <= N <= 1e3
 *
 * Triangle Number: A number generated by adding all natural numbers prior to
 * and including itself.
 *
 * e.g.: N = 5
 *       1st = 1 from [1] -> {1]
 *       2nd = 3 from [1+2] -> {1,3}
 *       3rd = 6 from [1+2+3] -> {1,2,3,6}
 *       4th = 10 from [1+2+3+4] -> {1,2,5,10}
 *       5th = 15 from [1+2+3+4+5] -> {1,3,5,15}
 *       6th = 21 from [1+2+3+4+5+6] -> {1,3,7,21}
 *       7th = 28 from [1+2+3+4+5+6+7] -> {1,2,4,7,14,28}
 *       result = 28
 */

#include <numeric>

#include "../../doctest/doctest.h"

#include "pe-maths/gauss-sum.h"
#include "pe-maths/primes.h"
#include "pe-maths/prime-factors.h"

/**
 * Counts unique divisors of n using prime decomposition.
 *
 * e.g. 28 = 2^2 * 7^1, therefore
 *
 * number of divisors of 28 = (2 + 1) * (1 + 1) = 6 -> {1, 2, 4, 7, 14, 28}
 */
unsigned short countDivisors(unsigned short n)
{
    const auto factors = primeFactors(n);

    return std::accumulate(
            factors.cbegin(),
            factors.cend(),
            1,
            [](unsigned short acc, std::pair<unsigned long long, unsigned long> pf) {
                return acc * (pf.second + 1);
            });
}

/**
 * Returns the found triangle number generated as a Gaussian sum that has had its
 * divisors counted using prime decomposition.
 *
 * Since the components of a Gaussian sum (n & n+1) are co-prime (i.e. they can have
 * neither a common prime factor nor a common divisor), the amount of divisors can be
 * assessed based on the cycling formulae:
 *
 *      t represents Gaussian sum = n(n + 1)/2
 *
 *      (even n) D(t) = D(n/2) * D(n+1)
 *      D(n+1) becomes D(n) for the next number, which will be odd.
 *
 *      (odd n) D(t) = D(n) * D((n+1)/2)
 */
unsigned long firstTriangleOverNBrute(unsigned short n)
{
    if (n == 1)
        return 3;

    // t = D(2) = D(1) * D(3)
    // dn1 = D(3) = 2
    unsigned short t {2}, dn1 {2}, count {2};
    while (count <= n) {
        t++;
        auto dn2 = t % 2 ? countDivisors((t + 1) / 2) : countDivisors(t + 1);
        count = dn1 * dn2;
        dn1 = dn2;
    }

    return gaussSum(t);
}

/**
 * Stores cumulative divisor counts in an array for quick access instead of calculating
 * the count for every new n.
 *
 * Dual cyclic formulae use n - 1 instead of n + 1 to match the index used in the cached
 * list.
 *
 * N.B. nMax was found by exhausting all solutions for n = [1, 1000] & finding the
 * maximum of the ratios of t:n. At n = 1000, the valid triangle number is the 41041st
 * term.
 */
unsigned long firstTriangleOverN(unsigned short n)
{
    const unsigned short nMax = std::min(n * 53, 41100);
    // cannot use array because variable-sized object cannot be initialised;
    // would have to use dynamic memory allocation to create an array during run-time.
    // unsigned long arr[nMax] {} would have to be used as, without {}, elements
    // would not be instantiated to default value.
    std::vector<unsigned short> divisorCount(nMax, 0);
    unsigned short num {0}, dT {0};

    while (dT <= n) {
        num++;
        for (int i = num; i < nMax; i += num) {
            divisorCount[i]++;
        }
        if (num % 2) {
            dT = divisorCount[num] * divisorCount[(num-1)/2];
        } else {
            dT = divisorCount[num/2] * divisorCount[num-1];
        }
    }

    return num * (num - 1) / 2;
}

/**
 * Generates primes to count number of divisors based on prime factorisation.
 */
unsigned long firstTriangleOverNUsingPrimes(unsigned short n)
{
    if (n == 1)
        return 3;

    const auto primes = primeNumbers(n * 2);
    unsigned long prime {3};

    unsigned short dn {2};  // min num of divisors for any prime
    unsigned short count {0};
    while (count <= n) {
        prime++;
        auto n1 = prime;
        if (!(n1 % 2))
            n1 /= 2;
        unsigned short dn1 {1};
        for (auto& p : primes) {
            // when the prime divisor would be greater than the residual n1
            // that residual n1 is the last prime factor with an exponent == 1.
            // so no need to identify it.
            if (p * p > n1) {
                dn1 *= 2;
                break;
            }
            unsigned short exponent {1};
            while (!(n1 % p)) {
                exponent++;
                n1 /= p;
            }
            if (exponent > 1)
                dn1 *= exponent;
            if (n1 == 1)
                break;
        }
        count = dn * dn1;
        dn = dn1;
    }

    return prime * (prime - 1) / 2;
}

TEST_CASE("test countDivisors()") {
    unsigned short nValues[] { 2, 3, 6, 28, 144, 3455, 10'000};
    unsigned short expected[] {2, 2, 4, 6, 15, 4, 25};

    for (const auto& n: nValues) {
        auto i = &n - &nValues[0];
        CHECK_EQ(expected[i], countDivisors(n));
    }
}

TEST_SUITE("test firstTriangleOverN()") {
    TEST_CASE("with lower constraints") {
        unsigned short nValues[] {1, 2, 4, 5, 12};
        unsigned long expected[] {3, 6, 28, 28, 120};

        for (const auto& n: nValues) {
            auto i = &n - &nValues[0];
            CHECK_EQ(expected[i], firstTriangleOverNBrute(n));
            CHECK_EQ(expected[i], firstTriangleOverN(n));
            CHECK_EQ(expected[i], firstTriangleOverNUsingPrimes(n));
        }
    }

    TEST_CASE("with upper constraints") {
        unsigned short nValues[] {500, 900, 1000};
        unsigned long expected[] {76'576'500, 842'161'320, 842'161'320};

        for (const auto& n: nValues) {
            auto i = &n - &nValues[0];
            CHECK_EQ(expected[i], firstTriangleOverNBrute(n));
            CHECK_EQ(expected[i], firstTriangleOverN(n));
            CHECK_EQ(expected[i], firstTriangleOverNUsingPrimes(n));
        }
    }
}