/*
 * Problem 29: Distinct Powers
 *
 * https://projecteuler.net/problem=29
 *
 * Goal: Count the distinct terms in a sequence generated by a^b when 2 <= a <= N and
 * 2 <= b <= N.
 *
 * Constraints: 2 <= N <= 1e5
 *
 * e.g.: N = 4
 *       terms = {4, 8, 16}, {9, 27, 81}, {16, 64, 256}
 *       count = 8
 */

#include <set>

#include "../../doctest/doctest.h"

#include "pe-custom/big-int.h"

unsigned long long distinctPowersBrute(unsigned long n)
{
    std::set<BigInt> distinct;

    for (int a {2}; a <= n; ++a) {
        for (int b {2}; b <= n; ++b) {
            auto power = BigInt {1uLL * a}.pow(BigInt {1uLL * b});
            distinct.insert(power);
        }
    }

    return distinct.size();
}

/*
 * Solution finds the amount of duplicate terms produced by a^b and subtracts that from
 * the maximum integer combinations, (n - 1)^2. No need to calculate base 2 exponents
 * larger than 16 since 2^17 > 1e5 (upper constraint).
 */
unsigned long long distinctPowers(unsigned long n)
{
    auto maxExp = std::min(16uL, n - 1);
    std::vector<unsigned long> minExponents(n*maxExp-1);
    for (int i {1}; i <= maxExp; ++i) {
        for (int j {2}; j <= n; ++j) {
            auto index = i * j - 2;
            if (!minExponents[index])
                minExponents[index] = i;
        }
    }

    std::vector<unsigned long> bases(n-1, 0);
    unsigned long long duplicates {};
    std::vector<unsigned long long> exponentDuplicates(maxExp-1, 0);
    for (unsigned long num {2}; num <= n; ++num) {
        auto parent = bases[num-2];
        if (!parent) {
            unsigned long long power = num * num;
            while (power <= n) {
                bases[power-2] = num;
                power *= num;
            }
        }
        else {
            unsigned long reduce {num}, exponent {};
            while (reduce > 1) {
                reduce /= parent;
                exponent++;
            }
            if (exponentDuplicates[exponent-2]) {
                duplicates += exponentDuplicates[exponent-2];
            }
            else {
                unsigned long long dupes {};
                for (int y {2}; y <= n; ++y) {
                    if (minExponents[y*exponent-2] < exponent)
                        dupes++;
                }
                exponentDuplicates[exponent-2] = dupes;
                duplicates += dupes;
            }
        }
    }

    unsigned long long allPowers = n - 1;
    return allPowers * allPowers - duplicates;
}

TEST_CASE("test lower constraints") {
    unsigned long nValues[] {2, 3, 4, 5, 10};
    unsigned long long expected[] {1, 4, 8, 15, 69};

    for (const auto& n: nValues) {
        auto i = &n - &nValues[0];
        CHECK_EQ(expected[i], distinctPowersBrute(n));
        CHECK_EQ(expected[i], distinctPowers(n));
    }
}

TEST_CASE("test mid constraints") {
    unsigned long nValues[] {20, 50, 100, 200};
    unsigned long long expected[] {324, 2184, 9183, 37774};

    for (const auto& n: nValues) {
        auto i = &n - &nValues[0];
        CHECK_EQ(expected[i], distinctPowersBrute(n));
        CHECK_EQ(expected[i], distinctPowers(n));
    }
}

TEST_CASE("test upper constraints") {
    unsigned long n {1000};
    unsigned long long expected {977'358};

    CHECK_EQ(expected, distinctPowers(n));
}